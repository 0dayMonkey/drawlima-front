<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawlima - Collaborative Whiteboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    
    <script>
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    !function(t){"use strict";var e,r="object"==typeof G&&G,n=r&&r.regeneratorRuntime;if(n)t.exports=n;else{var o=(t.exports=new function t(){this.wrap=function(t,e,r,n){var o=Object.create((e||t.prototype).constructor.prototype),i=new u(n||[]);return o._invoke=function(t,e,r){var n="suspendedStart";return function(o,a){if("executing"===n)throw new Error("Generator is already running");if("completed"===n){if("throw"===o)throw a;return{value:void 0,done:!0}}for(r.method=o,r.arg=a;;){var i=r.delegate;if(i){var c=f(i,r);if(c){if(c===s)continue;return c}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if("suspendedStart"===n)throw n="completed",r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n="executing";var l=a(t,e,r);if("object"==typeof l&&l.then){var p=l;l=null,p.then(function(t){f(p,t)},function(t){f(p,t)})}else{var d=l.iterator[r.method];if(void 0===d){if(n="completed","throw"===r.method)throw l;return{value:l,done:!0}}var h=a(d,l.iterator,r.arg);if("throw"===h.type)throw n="completed",h.arg;var v=h.value;return v&&"object"==typeof v&&v.then?void(n="suspendedYield",v.then(function(t){r.sent=r._sent=t;var e=a(c,"next",r);f(e)},function(t){f(a(c,"throw",t))})):(r.sent=r._sent=v,{value:v,done:!1})}}}(t,r,i,o),o};var n,a="function"==typeof Symbol,i=a&&Symbol.iterator,c=a&&Symbol.asyncIterator,s={};function u(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(l,this),this.reset(!0)}function f(t,r){if(t.یرܒ,"throw"===r.type)throw t.یرܒ=void 0,r.arg;return t.next(r.arg)}function l(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function p(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function d(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(l,this),this.done=!1,this.delegate=null,this.next=f,this["return"]=function(e,r){this. ολο=r,this.abrupt("return",e)},this["throw"]=function(t){throw this.abrupt("throw",t),t},this.delegate=null}function h(t,e){this.method=t,this.arg=e}u.prototype={constructor:u,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.completion=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(p),!t)for(var r in this)"t"===r.charAt(0)&&Object.prototype.hasOwnProperty.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=void 0)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var r=this;function n(e,n){return i.type="throw",i.arg=t,r.next=e,n&&(r.method="next",r.arg=void 0),!!n}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],i=a.completion;if("root"===a.tryLoc)return n("end");if(a.tryLoc<=this.prev){var c=Object.prototype.hasOwnProperty.call(a,"catchLoc"),s=Object.prototype.hasOwnProperty.call(a,"finallyLoc");if(c&&s){if(this.prev<a.catchLoc)return n(a.catchLoc,!0);if(this.prev<a.finallyLoc)return n(a.finallyLoc)}else if(c){if(this.prev<a.catchLoc)return n(a.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return n(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&Object.prototype.hasOwnProperty.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var o=n;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var a=o?o.completion:{};return a.type=t,a.arg=e,o?(this.method="next",this.next=o.finallyLoc,a):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),s},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),p(r),s}},"catch":function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;p(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(t,e,r){return this.delegate={iterator:t,method:e,arg:r},this.next="next",s}},d.prototype.next=function(t){return this.delegate.iterator[this.method](this.arg)},d.prototype["return"]=function(t){return this.delegate.iterator["return"](t)},d.prototype["throw"]=function(t){return this.delegate.iterator["throw"](t)},e=d.prototype,a&&(n=e[i])&&(e[c]=function(){return this}),e.toString=function(){return"[object Generator]"},t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=g,u.prototype[c]=function(){return this};var v={};function g(t){if(t){var e=t[i];if(e)return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,n=function e(){for(;++r<t.length;)if(Object.prototype.hasOwnProperty.call(t,r))return e.value=t[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return n.next=n}}return{next:m}}function m(){return{value:void 0,done:!0}}t.values=g,v.чы=function(){return this},Object.setPrototypeOf(e,v)}}("object"==typeof module?module:"object"==typeof exports?exports:"object"==typeof global?global:this);
    !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).uuid={})}(this,(function(e){"use strict";var t,r,n=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function o(e){return"string"==typeof e&&n.test(e)}var i=[],a=0;function s(e){var t=e.length;if(t>65535)throw new Error("Too many bytes passed in a single call to write(): "+t);for(var r=new Uint8Array(2*t),n=0;n<t;n++){var o=e.charCodeAt(n);r[2*n]=o,r[2*n+1]=o>>>8}return r}function u(e,t,r,n){t=t||i;var o=r||0,s=n||0;if(e.length-s<16)throw new Error("Namespace UUID too short");for(var u=new Uint8Array(16),c=0;c<16;c++)u[c]=e.charCodeAt(s+c);var f=new Uint8Array(16);for(c=0;c<16;c++)f[c]=u[c];var l=0;for(c=0;c<t.length;c++){var d=t[c];if("string"==typeof d&&(d=s(d)),d.length){for(var v=0;v<d.length;v++){var p=f[l%16]^d[v];f[l%16]=p,l++}if(l>=256){for(var h=0;h<16;h++)f[h]=f[h]^u[h];l=0}}}for(var g=0;g<16;g++)f[g]=f[g]^u[g];return(n||y)(void 0,{buffer:f})}for(var c=0;c<256;++c)i[c]=(c+256).toString(16).substr(1);function f(e,t){var r=t||0,n=i;return[n[e[r++]],n[e[r++]],n[e[r++]],n[e[r++]],"-",n[e[r++]],n[e[r++]],"-",n[e[r++]],n[e[r++]],"-",n[e[r++]],n[e[r++]],"-",n[e[r++]],n[e[r++]],n[e[r++]],n[e[r++]]].join("")}var l=0,d=0;function v(e,n,o){var i=(e=e||{},n=n||[],o=o||0),s=i.node||t,u=void 0!==i.clockseq?i.clockseq:r;if(null==s||null==u){var c=i.random||(i.rng||function(){if(!l&&!d){var e=new Uint8Array(16);("undefined"!=typeof crypto&&crypto.getRandomValues||"undefined"!=typeof msCrypto&&msCrypto.getRandomValues)&&crypto.getRandomValues(e),l=e[0]|e[1]<<8|e[2]<<16|e[3]<<24,d=e[4]|e[5]<<8|e[6]<<16|e[7]<<24}var t=l,r=d;return l=r,d=t,[(t|2147483648)>>>0,(r|2147483648)>>>0]}())();null==s&&(s=t=[1|c[0],c[1],c[2],c[3],c[4],c[5]]),null==u&&(u=r=16383&(c[6]<<8|c[7]))}var v="number"==typeof i.msecs?i.msecs:Date.now(),p="number"==typeof i.nsecs?i.nsecs:a+1,h=v-1322400000000+(p-a)/1e4;if(a=p,h<0&&"number"==typeof i.msecs&&(h=-h),h>268435455){var g=new Uint8Array(8);g[0]=255&h,g[1]=h>>>8&255,g[2]=h>>>16&255,g[3]=h>>>24&255,h=g}for(var m=h>>>28,w=h>>>16&4095,y=h&65535,b=new Uint8Array(8),A=0;A<8;A++)b[A]=h>>>8*(7-A)&255;for(var U=new Uint8Array(8),E=0;E<8;E++)U[E]=b[E];var T=u;for(E=0;E<2;E++)U[E]=U[E]|s[E];U[2]=U[2]|s[2],U[3]=U[3]|s[3],U[4]=U[4]|s[4],U[5]=U[5]|s[5];var N=h%4294967296;for(E=0;E<4;E++)U[E]=N>>>8*E&255;var D=u;for(E=0;E<2;E++)U[6+E]=D>>>8*E&255;var C=new Uint8Array(16);for(E=0;E<16;E++)C[E]=U[E];return n[o++]=y>>8&255,n[o++]=255&y,n[o++]=w>>8&255,n[o++]=255&w,n[o++]=m>>8&255,n[o++]=255&m,n[o++]=T>>8&255,n[o++]=255&T,n[o++]=s[0],n[o++]=s[1],n[o++]=s[2],n[o++]=s[3],n[o++]=s[4],n[o++]=s[5],n}function p(e,t,r){var n=function(e,n,o,i,s){var u="string"==typeof i?s(i,n):i;u.length;var c=u.slice(o,o+16);if(16!==c.length)throw new Error("Invalid bytes");return c[6]=15&c[6]|64,c[8]=63&c[8]|128,f(c)}(0,0,0,e,t);if(!o(n))throw new TypeError("Invalid UUID");var r=new Uint8Array(16);return r[0]=parseInt(n.slice(0,2),16),r[1]=parseInt(n.slice(2,4),16),r[2]=parseInt(n.slice(4,6),16),r[3]=parseInt(n.slice(6,8),16),r[4]=parseInt(n.slice(9,11),16),r[5]=parseInt(n.slice(11,13),16),r[6]=parseInt(n.slice(14,16),16),r[7]=parseInt(n.slice(16,18),16),r[8]=parseInt(n.slice(19,21),16),r[9]=parseInt(n.slice(21,23),16),r[10]=parseInt(n.slice(24,26),16),r[11]=parseInt(n.slice(26,28),16),r[12]=parseInt(n.slice(28,30),16),r[13]=parseInt(n.slice(30,32),16),r[14]=parseInt(n.slice(32,34),16),r[15]=parseInt(n.slice(34,36),16),r}function h(e,t,r,n){var i=(e=e||{},"random");if("function"!=typeof(t=e.rng||t))throw new Error("Cannot create URL-friendly UUIDs with a non-function RNG");for(var o=new Uint8Array(16),a=0;a<16;a+=4){var s=t();o[a]=s>>>24,o[a+1]=s>>>16&255,o[a+2]=s>>>8&255,o[a+3]=255&s}var u=f(o),c=btoa(String.fromCharCode.apply(String,o)).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_");if(r)return c;var l=p(u);return n(void 0,{buffer:l})}function g(e,t,r){var n=(e=e||{}).random||(e.rng||function(){if(!l&&!d){var e=new Uint8Array(16);("undefined"!=typeof crypto&&crypto.getRandomValues||"undefined"!=typeof msCrypto&&msCrypto.getRandomValues)&&crypto.getRandomValues(e),l=e[0]|e[1]<<8|e[2]<<16|e[3]<<24,d=e[4]|e[5]<<8|e[6]<<16|e[7]<<24}var t=l,r=d;return l=r,d=t,[(t|2147483648)>>>0,(r|2147483648)>>>0]}())();n[6]=15&n[6]|64,n[8]=63&n[8]|128;var o=new Uint8Array(16),i=0;for(var a in n)o[i++]=n[a];if(t){for(var s=0;s<16;s++)t[r+s]=o[s];return t}return f(o)}var m=g;m.v1=v,m.v3=u,m.v4=g,m.v5=u,m.NIL="00000000-0000-0000-0000-000000000000",m.version=function(e){if(!o(e))throw new TypeError("Invalid UUID");return parseInt(e.substr(14,1),16)},m.validate=o,m.stringify=f,m.parse=p,m.v1ToV4=function(e,t){var r=p(e);return r[6]=15&r[6]|64,r[8]=63&r[8]|128,t?f(r):r},m.v6=function(e,t,r){var n=(e=e||{},n=n||[],r=r||0,e.random||(e.rng||function(){if(!l&&!d){var e=new Uint8Array(16);("undefined"!=typeof crypto&&crypto.getRandomValues||"undefined"!=typeof msCrypto&&msCrypto.getRandomValues)&&crypto.getRandomValues(e),l=e[0]|e[1]<<8|e[2]<<16|e[3]<<24,d=e[4]|e[5]<<8|e[6]<<16|e[7]<<24}var t=l,r=d;return l=r,d=t,[(t|2147483648)>>>0,(r|2147483648)>>>0]}())()),o=Date.now(),i=new Uint8Array(8);i[0]=o>>>24,i[1]=o>>>16&255,i[2]=o>>>8&255,i[3]=255&o;for(var a=0;a<4;a++)i[a+4]=n[a];return f(i)},m.v7=function(e,t,r){var n=(e=e||{},n=n||[],r=r||0,e.random||(e.rng||function(){if(!l&&!d){var e=new Uint8Array(16);("undefined"!=typeof crypto&&crypto.getRandomValues||"undefined"!=typeof msCrypto&&msCrypto.getRandomValues)&&crypto.getRandomValues(e),l=e[0]|e[1]<<8|e[2]<<16|e[3]<<24,d=e[4]|e[5]<<8|e[6]<<16|e[7]<<24}var t=l,r=d;return l=r,d=t,[(t|2147483648)>>>0,(r|2147483648)>>>0]}())()),o=Date.now(),i=new Uint8Array(8);i[0]=o>>>24,i[1]=o>>>16&255,i[2]=o>>>8&255,i[3]=255&o;for(var a=0;a<4;a++)i[a+4]=n[a];return f(i)},m.v8=function(e,t,r){(e=e||{}).custom;var n=e.random||(e.rng||function(){if(!l&&!d){var e=new Uint8Array(16);("undefined"!=typeof crypto&&crypto.getRandomValues||"undefined"!=typeof msCrypto&&msCrypto.getRandomValues)&&crypto.getRandomValues(e),l=e[0]|e[1]<<8|e[2]<<16|e[3]<<24,d=e[4]|e[5]<<8|e[6]<<16|e[7]<<24}var t=l,r=d;return l=r,d=t,[(t|2147483648)>>>0,(r|2147483648)>>>0]}())();return n[6]=15&n[6]|64,n[8]=63&n[8]|128,f(n)},m.URL_NAMESPACE="6ba7b810-9dad-11d1-80b4-00c04fd430c8",m.DNS_NAMESPACE="6ba7b811-9dad-11d1-80b4-00c04fd430c8",m.OID_NAMESPACE="6ba7b812-9dad-11d1-80b4-00c04fd430c8",m.X500_NAMESPACE="6ba7b814-9dad-11d1-80b4-00c04fd430c8",e.NIL=m.NIL,e.URL=m.URL_NAMESPACE,e.DNS=m.DNS_NAMESPACE,e.OID=m.OID_NAMESPACE,e.X500=m.X500_NAMESPACE,e.parse=p,e.stringify=f,e.v1=v,e.v3=u,e.v4=m,e.v5=u,e.v6=m.v6,e.v7=m.v7,e.v8=m.v8,e.validate=o,e.version=m.version,Object.defineProperty(e,"__esModule",{value:!0})}));
    </script>

    <style type="text/tailwindcss">
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #F8F9FA; /* Light neutral canvas background */
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }
        /* Custom classes for Claude-inspired UI */
        @layer components {
            .card {
                @apply bg-white rounded-xl shadow-lg transition-all;
            }
            .btn {
                @apply px-4 py-2 rounded-lg font-semibold text-white transition-all duration-150 ease-in-out;
            }
            .btn-primary {
                @apply bg-blue-500 hover:bg-blue-600 active:scale-[0.98];
            }
            .btn-secondary {
                @apply bg-gray-200 text-gray-700 hover:bg-gray-300 active:scale-[0.98];
            }
            .input-field {
                @apply w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-400;
            }
        }
        /* Cursors */
        .drawing-cursor { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='black' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='4'/></svg>") 12 12, auto; }
        .eraser-cursor { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/></svg>") 12 12, auto; }
        .panning-cursor { cursor: grab; }
        .panning-cursor:active { cursor: grabbing; }

        /* Smooth transitions */
        .fade-in { animation: fadeIn 0.5s ease-in-out forwards; }
        .fade-out { animation: fadeOut 0.5s ease-in-out forwards; }
        .slide-up { animation: slideUp 0.5s ease-in-out forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; display: none; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    </style>
</head>
<body class="overflow-hidden">

    <div id="app-container" class="w-screen h-screen">

        <div id="modal-username" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-50 fade-in">
            <div class="card w-full max-w-sm p-8 text-center">
                <h1 class="text-2xl font-bold text-gray-800 mb-2">Welcome to Drawlima</h1>
                <p class="text-gray-500 mb-6">Choose a username to start collaborating.</p>
                <form id="form-username">
                    <input type="text" id="input-username" placeholder="Enter your name..." class="input-field mb-4" required>
                    <button type="submit" class="btn btn-primary w-full">Continue</button>
                </form>
            </div>
        </div>

        <div id="view-lobby" class="hidden w-full h-full p-4 md:p-8 overflow-y-auto">
            <div class="max-w-4xl mx-auto">
                <div class="flex justify-between items-center mb-6">
                    <h1 class="text-3xl font-bold text-gray-800">Whiteboards</h1>
                    <div class="flex items-center gap-4">
                        <span class="text-sm text-gray-600">Connected as: <strong id="lobby-username" class="font-semibold text-gray-800"></strong></span>
                        <button id="btn-logout-lobby" class="btn btn-secondary text-sm !px-3 !py-1.5">Logout</button>
                        <button id="btn-create-new" class="btn btn-primary">Create New</button>
                    </div>
                </div>
                <div id="whiteboard-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    </div>
            </div>
        </div>
        
        <div id="modal-create-whiteboard" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-50">
            <div class="card w-full max-w-sm p-8">
                <h2 class="text-xl font-bold mb-4">Create a New Whiteboard</h2>
                <form id="form-create-whiteboard">
                    <label for="input-whiteboard-name" class="block text-sm font-medium text-gray-600 mb-1">Name</label>
                    <input type="text" id="input-whiteboard-name" placeholder="My Awesome Project" class="input-field mb-4" required>

                    <label for="select-whiteboard-size" class="block text-sm font-medium text-gray-600 mb-1">Canvas Size</label>
                    <select id="select-whiteboard-size" class="input-field mb-6">
                        <option value="1000x1000">Small (1000 x 1000)</option>
                        <option value="3000x3000" selected>Medium (3000 x 3000)</option>
                        <option value="5000x5000">Large (5000 x 5000)</option>
                    </select>
                    <div class="flex justify-end gap-3">
                        <button type="button" id="btn-cancel-create" class="btn btn-secondary">Cancel</button>
                        <button type="submit" class="btn btn-primary">Create</button>
                    </div>
                </form>
            </div>
        </div>


        <div id="view-whiteboard" class="hidden w-full h-full relative">
            <canvas id="whiteboard-canvas" class="absolute top-0 left-0"></canvas>
            <div id="cursors-container" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>

            <div id="toolbar" class="absolute bottom-4 left-1/2 -translate-x-1/2 flex items-center gap-2 p-2 card slide-up">
                <div class="flex items-center gap-1">
                    <button class="color-btn w-6 h-6 rounded-full border-2 border-blue-500" style="background-color: #EF4444;" data-color="#EF4444"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #F97316;" data-color="#F97316"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #84CC16;" data-color="#84CC16"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #3B82F6;" data-color="#3B82F6"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #8B5CF6;" data-color="#8B5CF6"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #000000;" data-color="#000000"></button>
                    <input type="color" id="color-picker-native" class="w-0 h-0 opacity-0 absolute">
                    <button id="btn-more-colors" class="w-6 h-6 rounded-full flex items-center justify-center bg-gray-200 text-gray-600">+</button>
                </div>
                <div class="h-6 w-px bg-gray-200"></div>
                <div class="flex items-center gap-2">
                    <span class="text-sm">Size:</span>
                    <input type="range" id="thickness-slider" min="2" max="50" value="5" class="w-24">
                </div>
                <div class="h-6 w-px bg-gray-200"></div>
                <button id="tool-brush" class="p-2 rounded-md bg-blue-100 text-blue-600">Brush</button>
                <button id="tool-eraser" class="p-2 rounded-md">Eraser</button>
                 <div class="h-6 w-px bg-gray-200"></div>
                <button id="btn-back-to-lobby" class="btn btn-secondary text-sm">Lobby</button>
            </div>
            
            <div id="user-list-overlay" class="absolute top-4 right-4 card p-3 flex flex-col gap-2">
                <div>
                    <h3 class="font-semibold text-sm mb-2">Online</h3>
                    <div id="user-list-content" class="flex flex-col gap-1"></div>
                </div>
                <div class="border-t border-gray-200 pt-2 mt-1">
                    <span class="text-xs text-gray-500">Connected as: <strong id="whiteboard-username" class="font-medium text-gray-700"></strong></span>
                    <button id="btn-logout-whiteboard" class="block w-full text-left text-sm text-red-500 hover:text-red-700 font-semibold mt-1">Logout</button>
                </div>
           </div>
        </div>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- CONFIGURATION ---
        const WS_URL = 'wss://miaou.vps.webdock.cloud/drawlima/';

        // --- STATE MANAGEMENT ---
        let ws;
        let userId = null; // Our persistent ID
        let username = null;
        let currentRoomId = null;
        let otherUsersInRoom = new Map(); // { userId -> { username } }
        let userCursors = new Map(); // { userId -> { element, color, username, worldX, worldY } }
        
        // Drawing state
        let committedStrokes = []; // Strokes that are finished
        let activeStrokes = new Map(); // Strokes currently being drawn {strokeId -> strokeObject}

        // Local user's drawing/panning state
        let localAction = {
            isDrawing: false,
            isPanning: false,
            isErasing: false,
            currentStrokeId: null,
            panStart: { x: 0, y: 0 },
            touchStartDist: 0,
            lastSentCursorTime: 0
        };
        
        let tool = 'brush';
        let drawingConfig = {
            color: '#EF4444',
            thickness: 5,
        };
        
        // Viewport (camera) state
        let viewport = {
            panX: 0, panY: 0, zoom: 1,
            worldWidth: 3000, worldHeight: 3000
        };

        // --- DOM ELEMENTS ---
        const usernameModal = document.getElementById('modal-username');
        const usernameForm = document.getElementById('form-username');
        const usernameInput = document.getElementById('input-username');
        const lobbyView = document.getElementById('view-lobby');
        const whiteboardListEl = document.getElementById('whiteboard-list');
        const createNewBtn = document.getElementById('btn-create-new');
        const createModal = document.getElementById('modal-create-whiteboard');
        const createForm = document.getElementById('form-create-whiteboard');
        const cancelCreateBtn = document.getElementById('btn-cancel-create');
        const whiteboardView = document.getElementById('view-whiteboard');
        const canvas = document.getElementById('whiteboard-canvas');
        const ctx = canvas.getContext('2d');
        const cursorsContainer = document.getElementById('cursors-container');
        const userListOverlay = document.getElementById('user-list-overlay');
        const userListContent = document.getElementById('user-list-content');
        const toolbar = document.getElementById('toolbar');
        const colorBtns = document.querySelectorAll('.color-btn');
        const moreColorsBtn = document.getElementById('btn-more-colors');
        const nativeColorPicker = document.getElementById('color-picker-native');
        const thicknessSlider = document.getElementById('thickness-slider');
        const brushToolBtn = document.getElementById('tool-brush');
        const eraserToolBtn = document.getElementById('tool-eraser');
        const backToLobbyBtn = document.getElementById('btn-back-to-lobby');
        const lobbyUsernameEl = document.getElementById('lobby-username');
        const whiteboardUsernameEl = document.getElementById('whiteboard-username');
        const logoutLobbyBtn = document.getElementById('btn-logout-lobby');
        const logoutWhiteboardBtn = document.getElementById('btn-logout-whiteboard');

        // --- INITIALIZATION ---
        function init() {
            const savedUserId = localStorage.getItem('drawlima_userId');
            const savedUsername = localStorage.getItem('drawlima_username');

            if (savedUserId && savedUsername) {
                handleAuthentication(savedUsername, savedUserId);
            } else {
                usernameModal.classList.remove('hidden');
            }
            
            usernameForm.addEventListener('submit', handleUsernameSubmit);
            createNewBtn.addEventListener('click', () => createModal.classList.remove('hidden'));
            cancelCreateBtn.addEventListener('click', () => createModal.classList.add('hidden'));
            createForm.addEventListener('submit', handleCreateRoom);
            backToLobbyBtn.addEventListener('click', handleLeaveRoom);
            window.addEventListener('resize', resizeCanvas);
            logoutLobbyBtn.addEventListener('click', handleLogout);
            logoutWhiteboardBtn.addEventListener('click', handleLogout);

            setupToolbar();
            setupCanvasEvents();
        }

        // --- AUTH & WEBSOCKET FLOW ---
        function handleUsernameSubmit(e) {
            e.preventDefault();
            const name = usernameInput.value.trim();
            if (name) {
                handleAuthentication(name);
            }
        }

        function handleAuthentication(name, token = null) {
            username = name;
            userId = token;
            usernameModal.classList.add('fade-out');
            setTimeout(() => usernameModal.classList.add('hidden'), 500);
            connectWebSocket();
        }
        
        function handleLogout() {
            localStorage.removeItem('drawlima_userId');
            localStorage.removeItem('drawlima_username');
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.onclose = null; 
                ws.close();
            }
            window.location.reload();
        }

        function connectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) return;
            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                sendMessage('auth', { 
                    username: username,
                    token: userId
                });
            };

            ws.onmessage = ({ data }) => {
                const message = JSON.parse(data);
                handleWebSocketMessage(message);
            };

            ws.onclose = () => {
                console.warn('WebSocket disconnected. Attempting to reconnect in 3s...');
                setTimeout(connectWebSocket, 3000);
            };
            ws.onerror = (error) => console.error('WebSocket error:', error);
        }

        function sendMessage(type, payload) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type, payload }));
            }
        }
        
        function handleWebSocketMessage({ type, payload }) {
            switch (type) {
                case 'authenticated':
                    userId = payload.userId;
                    localStorage.setItem('drawlima_userId', userId);
                    localStorage.setItem('drawlima_username', username);
                    lobbyUsernameEl.textContent = username;
                    whiteboardUsernameEl.textContent = username;
                    updateWhiteboardList(payload.whiteboards);
                    showView('lobby');
                    break;
                case 'room_list_update':
                    updateWhiteboardList(payload.whiteboards);
                    break;
                case 'joined_room':
                    currentRoomId = payload.roomId;
                    viewport.worldWidth = payload.size.width;
                    viewport.worldHeight = payload.size.height;
                    committedStrokes = payload.strokes;
                    // CORRECTED: Safely handle potentially missing activeStrokes array
                    activeStrokes = new Map((payload.activeStrokes || []).map(s => [s.id, s]));
                    otherUsersInRoom.clear();
                    payload.users.forEach(u => {
                        if (u.id !== userId) otherUsersInRoom.set(u.id, u);
                    });
                    showView('whiteboard');
                    setupWhiteboard();
                    break;
                case 'user_joined':
                    if (payload.user.id !== userId) {
                        otherUsersInRoom.set(payload.user.id, payload.user);
                        updateUserList();
                    }
                    break;
                case 'user_left':
                    otherUsersInRoom.delete(payload.userId);
                    removeCursor(payload.userId);
                    updateUserList();
                    break;
                case 'start_stroke':
                    activeStrokes.set(payload.id, payload);
                    redrawCanvas();
                    break;
                case 'draw_chunk':
                    const strokeToUpdate = activeStrokes.get(payload.strokeId);
                    if (strokeToUpdate) {
                        strokeToUpdate.points.push(payload.point);
                        drawStrokeSegment(strokeToUpdate, strokeToUpdate.points.length - 2);
                    }
                    break;
                case 'end_stroke':
                    const finishedStroke = activeStrokes.get(payload.strokeId);
                    if (finishedStroke) {
                        committedStrokes.push(finishedStroke);
                        activeStrokes.delete(payload.strokeId);
                        redrawCanvas();
                    }
                    break;
                case 'delete_stroke': // Note: Server sends 'stroke_deleted' but client had 'delete_stroke'
                    committedStrokes = committedStrokes.filter(s => s.id !== payload.strokeId);
                    redrawCanvas();
                    break;
                case 'stroke_deleted': // Handling the message from the server
                    committedStrokes = committedStrokes.filter(s => s.id !== payload.strokeId);
                    redrawCanvas();
                    break;
                case 'cursor_update':
                    updateCursor(payload);
                    break;
            }
        }
        
        // --- VIEW & ROOM MANAGEMENT ---
        function showView(view) {
            usernameModal.classList.add('hidden');
            lobbyView.classList.add('hidden');
            whiteboardView.classList.add('hidden');
            if (view === 'lobby') lobbyView.classList.remove('hidden');
            if (view === 'whiteboard') whiteboardView.classList.remove('hidden');
        }
        function updateWhiteboardList(whiteboards) {
            whiteboardListEl.innerHTML = '';
            if (!whiteboards || whiteboards.length === 0) {
                 whiteboardListEl.innerHTML = `<p class="text-gray-500 col-span-full text-center">No whiteboards yet. Why not create one?</p>`;
            } else {
                whiteboards.forEach(room => {
                    const card = document.createElement('div');
                    card.className = 'card p-4 flex flex-col justify-between hover:shadow-xl cursor-pointer';
                    card.dataset.roomId = room.id;
                    card.innerHTML = `<div><h3 class="font-bold text-lg truncate">${room.name}</h3><p class="text-sm text-gray-500">by ${room.creator}</p></div><div class="mt-4 text-sm text-gray-600 flex justify-between items-center"><span>${room.userCount} user(s) online</span><span>${new Date(room.createdAt).toLocaleDateString()}</span></div>`;
                    card.addEventListener('click', () => sendMessage('join_room', { roomId: room.id }));
                    whiteboardListEl.appendChild(card);
                });
            }
        }
        function handleCreateRoom(e) {
            e.preventDefault();
            const name = document.getElementById('input-whiteboard-name').value;
            const sizeValue = document.getElementById('select-whiteboard-size').value;
            const [width, height] = sizeValue.split('x').map(Number);
            if (name) {
                sendMessage('create_room', { name, size: {width, height} });
                createModal.classList.add('hidden');
                createForm.reset();
            }
        }
        function handleLeaveRoom() {
            showView('lobby');
            currentRoomId = null;
        }

        // --- CANVAS & DRAWING LOGIC ---
        function setupWhiteboard() {
            resizeCanvas();
            resetViewport();
            redrawCanvas();
            updateUserList();
            setCursor(tool);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            redrawCanvas();
        }
        
        function resetViewport() {
            viewport.panX = (canvas.width / 2) - (viewport.worldWidth / 2 * viewport.zoom);
            viewport.panY = (canvas.height / 2) - (viewport.worldHeight / 2 * viewport.zoom);
        }

        function setupCanvasEvents() {
            canvas.addEventListener('mousedown', startAction);
            canvas.addEventListener('mousemove', moveAction);
            canvas.addEventListener('mouseup', endAction);
            canvas.addEventListener('mouseout', endAction);
            canvas.addEventListener('wheel', handleZoom, { passive: false });
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
        }
        
        function startAction(e) {
            if (e.button === 2) {
                localAction.isPanning = true;
                localAction.panStart = { x: e.clientX, y: e.clientY };
                setCursor('panning');
                return;
            }
            if (e.button !== 0) return;
            
            let [worldX, worldY] = screenToWorld(e.clientX, e.clientY);
            worldX = Math.max(0, Math.min(viewport.worldWidth, worldX));
            worldY = Math.max(0, Math.min(viewport.worldHeight, worldY));

            if (tool === 'eraser') {
                localAction.isErasing = true;
                eraseAtPoint(worldX, worldY);
            } else {
                localAction.isDrawing = true;
                localAction.currentStrokeId = uuid.v4();
                
                const newStroke = {
                    id: localAction.currentStrokeId,
                    userId: userId,
                    tool: 'brush',
                    color: drawingConfig.color,
                    thickness: drawingConfig.thickness,
                    points: [{x: worldX, y: worldY}]
                };
                activeStrokes.set(localAction.currentStrokeId, newStroke);
                sendMessage('start_stroke', newStroke);
                redrawCanvas();
            }
        }

        function moveAction(e) {
            if (localAction.isPanning) {
                const dx = e.clientX - localAction.panStart.x;
                const dy = e.clientY - localAction.panStart.y;
                viewport.panX += dx;
                viewport.panY += dy;
                localAction.panStart = { x: e.clientX, y: e.clientY };
                redrawCanvas();
                updateAllCursorPositions();
                return;
            }

            let [worldX, worldY] = screenToWorld(e.clientX, e.clientY);
            worldX = Math.max(0, Math.min(viewport.worldWidth, worldX));
            worldY = Math.max(0, Math.min(viewport.worldHeight, worldY));

            const now = Date.now();
            if (now - localAction.lastSentCursorTime > 50) {
                 sendMessage('cursor_move', { x: worldX, y: worldY, color: drawingConfig.color });
                 localAction.lastSentCursorTime = now;
            }

            if (!localAction.isDrawing && !localAction.isErasing) return;
            
            if (localAction.isDrawing) {
                const current = activeStrokes.get(localAction.currentStrokeId);
                if (current) {
                    const newPoint = {x: worldX, y: worldY};
                    current.points.push(newPoint);
                    sendMessage('draw_chunk', { strokeId: localAction.currentStrokeId, point: newPoint });
                    drawStrokeSegment(current, current.points.length - 2);
                }
            } else if (localAction.isErasing) {
                eraseAtPoint(worldX, worldY);
            }
        }
        
        function endAction(e) {
            if (localAction.isPanning) {
                localAction.isPanning = false;
                setCursor(tool);
            }
            if (localAction.isDrawing) {
                const finishedStroke = activeStrokes.get(localAction.currentStrokeId);
                if (finishedStroke) {
                    sendMessage('end_stroke', { strokeId: localAction.currentStrokeId });
                    committedStrokes.push(finishedStroke);
                    activeStrokes.delete(localAction.currentStrokeId);
                }
            }
            localAction.isDrawing = false;
            localAction.isErasing = false;
            localAction.currentStrokeId = null;
        }
        
        function eraseAtPoint(x, y) {
            const eraserRadius = 10;
            let needsRedraw = false;
            for (let i = committedStrokes.length - 1; i >= 0; i--) {
                const stroke = committedStrokes[i];
                if (stroke.userId !== userId) continue;
                for (const point of stroke.points) {
                    if (Math.hypot(point.x - x, point.y - y) < eraserRadius / viewport.zoom) {
                        sendMessage('delete_stroke', { strokeId: stroke.id });
                        committedStrokes.splice(i, 1);
                        needsRedraw = true;
                        break; 
                    }
                }
                if (needsRedraw) break;
            }
            if (needsRedraw) redrawCanvas();
        }

        // --- DRAWING & RENDERING ---
        function redrawCanvas() {
            if (!currentRoomId) return;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();

            const [tlx, tly] = worldToScreen(0, 0);
            const [brx, bry] = worldToScreen(viewport.worldWidth, viewport.worldHeight);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(tlx, tly, brx - tlx, bry - tly);
            ctx.strokeStyle = '#E5E7EB';
            ctx.strokeRect(tlx, tly, brx - tlx, bry - tly);

            committedStrokes.forEach(drawFullStroke);
            activeStrokes.forEach(drawFullStroke);
        }

        function drawFullStroke(stroke) {
            if (!stroke || stroke.points.length < 1) return;
            ctx.beginPath();
            const startPoint = worldToScreen(stroke.points[0].x, stroke.points[0].y);
            ctx.moveTo(startPoint[0], startPoint[1]);
            ctx.lineWidth = stroke.thickness * viewport.zoom;
            ctx.strokeStyle = stroke.color;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            for (let i = 1; i < stroke.points.length; i++) {
                const point = worldToScreen(stroke.points[i].x, stroke.points[i].y);
                ctx.lineTo(point[0], point[1]);
            }
            ctx.stroke();
        }

        function drawStrokeSegment(stroke, fromIndex) {
            if (fromIndex < 0 || fromIndex >= stroke.points.length - 1) return;
            ctx.beginPath();
            const fromPoint = worldToScreen(stroke.points[fromIndex].x, stroke.points[fromIndex].y);
            const toPoint = worldToScreen(stroke.points[fromIndex + 1].x, stroke.points[fromIndex + 1].y);
            ctx.moveTo(fromPoint[0], fromPoint[1]);
            ctx.lineTo(toPoint[0], toPoint[1]);
            ctx.lineWidth = stroke.thickness * viewport.zoom;
            ctx.strokeStyle = stroke.color;
            ctx.lineCap = 'round';
            ctx.stroke();
        }

        // --- UI, HELPERS, & COORD-SYSTEM ---
        function setupToolbar() {
            colorBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    colorBtns.forEach(b => b.style.borderColor = 'transparent');
                    btn.style.borderColor = '#3B82F6';
                    drawingConfig.color = btn.dataset.color;
                    setTool('brush');
                });
            });
            moreColorsBtn.addEventListener('click', () => nativeColorPicker.click());
            nativeColorPicker.addEventListener('input', (e) => {
                drawingConfig.color = e.target.value;
                setTool('brush');
            });
            thicknessSlider.addEventListener('input', (e) => drawingConfig.thickness = e.target.value);
            brushToolBtn.addEventListener('click', () => setTool('brush'));
            eraserToolBtn.addEventListener('click', () => setTool('eraser'));
        }
        function setTool(newTool) {
            tool = newTool;
            brushToolBtn.classList.toggle('bg-blue-100', tool === 'brush');
            brushToolBtn.classList.toggle('text-blue-600', tool === 'brush');
            eraserToolBtn.classList.toggle('bg-blue-100', tool === 'eraser');
            eraserToolBtn.classList.toggle('text-blue-600', tool === 'eraser');
            setCursor(tool);
        }
        function setCursor(cursorType) {
            canvas.classList.remove('drawing-cursor', 'eraser-cursor', 'panning-cursor');
            if (cursorType === 'brush') canvas.classList.add('drawing-cursor');
            if (cursorType === 'eraser') canvas.classList.add('eraser-cursor');
            if (cursorType === 'panning') canvas.classList.add('panning-cursor');
        }
        function screenToWorld(x, y) { return [(x - viewport.panX) / viewport.zoom, (y - viewport.panY) / viewport.zoom]; }
        function worldToScreen(x, y) { return [x * viewport.zoom + viewport.panX, y * viewport.zoom + viewport.panY]; }
        
        function updateUserList() {
            userListContent.innerHTML = '';
            const selfEl = document.createElement('div');
            selfEl.className = 'text-sm font-semibold text-blue-600';
            selfEl.textContent = `${username} (You)`;
            userListContent.appendChild(selfEl);
            otherUsersInRoom.forEach(user => {
                 const userEl = document.createElement('div');
                 userEl.className = 'text-sm text-gray-600';
                 userEl.textContent = user.username;
                 userListContent.appendChild(userEl);
            });
        }

        function updateCursor({ userId, username, x, y, color }) {
            if (!userCursors.has(userId)) {
                const cursorEl = document.createElement('div');
                cursorEl.className = 'absolute transition-transform duration-100 ease-linear';
                cursorEl.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="${color}" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="transform -rotate-45"><path d="M21.19,2.81,2.81,21.19a2,2,0,0,1-2.83-2.83L18.36,1.64a2,2,0,0,1,2.83,2.83Z"/></svg><span class="absolute top-5 left-2 px-2 py-0.5 text-xs text-white rounded-full" style="background-color: ${color};">${username}</span>`;
                cursorsContainer.appendChild(cursorEl);
                userCursors.set(userId, { element: cursorEl, color, username, worldX: x, worldY: y });
            }
            const cursor = userCursors.get(userId);
            cursor.worldX = x;
            cursor.worldY = y;
            const [screenX, screenY] = worldToScreen(x, y);
            cursor.element.style.transform = `translate(${screenX}px, ${screenY}px)`;
            if(cursor.color !== color) {
                cursor.color = color;
                cursor.element.querySelector('svg').style.fill = color;
                cursor.element.querySelector('span').style.backgroundColor = color;
            }
        }
        function removeCursor(userId) {
            if (userCursors.has(userId)) {
                userCursors.get(userId).element.remove();
                userCursors.delete(userId);
            }
        }
        function updateAllCursorPositions() {
            userCursors.forEach(cursor => {
                const [screenX, screenY] = worldToScreen(cursor.worldX, cursor.worldY);
                cursor.element.style.transform = `translate(${screenX}px, ${screenY}px)`;
            });
        }
        
        // --- TOUCH & ZOOM HANDLERS ---
        function handleZoom(e) {
            e.preventDefault();
            const zoomAmount = e.deltaY * -0.001;
            const newZoom = Math.max(0.1, Math.min(5, viewport.zoom * (1 + zoomAmount)));
            const mouseX = e.clientX;
            const mouseY = e.clientY;
            const worldX = (mouseX - viewport.panX) / viewport.zoom;
            const worldY = (mouseY - viewport.panY) / viewport.zoom;
            viewport.panX = mouseX - worldX * newZoom;
            viewport.panY = mouseY - worldY * newZoom;
            viewport.zoom = newZoom;
            redrawCanvas();
            updateAllCursorPositions();
        }
        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                startAction({ button: 0, clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
            } else if (e.touches.length === 2) {
                localAction.isDrawing = localAction.isErasing = false;
                localAction.isPanning = true;
                localAction.panStart = { x: (e.touches[0].clientX + e.touches[1].clientX) / 2, y: (e.touches[0].clientY + e.touches[1].clientY) / 2 };
                localAction.touchStartDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                setCursor('panning');
            }
        }
        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                moveAction({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
            } else if (e.touches.length === 2 && localAction.isPanning) {
                const panNow = { x: (e.touches[0].clientX + e.touches[1].clientX) / 2, y: (e.touches[0].clientY + e.touches[1].clientY) / 2 };
                const dx = panNow.x - localAction.panStart.x;
                const dy = panNow.y - localAction.panStart.y;
                viewport.panX += dx;
                viewport.panY += dy;
                localAction.panStart = panNow;
                const touchNowDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                const zoomFactor = touchNowDist / localAction.touchStartDist;
                const newZoom = Math.max(0.1, Math.min(5, viewport.zoom * zoomFactor));
                const worldX = (panNow.x - viewport.panX) / viewport.zoom;
                const worldY = (panNow.y - viewport.panY) / viewport.zoom;
                viewport.panX = panNow.x - worldX * newZoom;
                viewport.panY = panNow.y - worldY * newZoom;
                viewport.zoom = newZoom;
                localAction.touchStartDist = touchNowDist;
                redrawCanvas();
                updateAllCursorPositions();
            }
        }
        function handleTouchEnd(e) {
            e.preventDefault();
            endAction(e);
            if(e.touches.length < 2) {
                 localAction.isPanning = false;
                 setCursor(tool);
            }
        }

        // --- Start the Application ---
        init();
    });
</script>

</body>
</html>
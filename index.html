<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Drawlima - Collaborative Whiteboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    
    <script>
    // Inlined UUID.js library - no changes here
    (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
      typeof define === 'function' && define.amd ? define(['exports'], factory) :
      (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.uuid = {}));
    }(this, (function (exports) { 'use strict';
      var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
      function validate(uuid) { return typeof uuid === 'string' && REGEX.test(uuid); }
      var byteToHex = [];
      for (var i = 0; i < 256; ++i) { byteToHex.push((i + 0x100).toString(16).substr(1)); }
      function stringify(arr) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
        if (!validate(uuid)) { throw TypeError('Stringified UUID is invalid'); }
        return uuid;
      }
      var _nodeId;
      var _clockseq;
      var _lastMSecs = 0;
      var _lastNSecs = 0;
      function v1(options, buf, offset) {
        var i = buf && offset || 0;
        var b = buf || new Array(16);
        options = options || {};
        var node = options.node || _nodeId;
        var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
        if (node == null || clockseq == null) {
          var seedBytes = options.random || (options.rng || rng)();
          if (node == null) { node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]]; }
          if (clockseq == null) { clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff; }
        }
        var msecs = options.msecs !== undefined ? options.msecs : Date.now();
        var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
        var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;
        if (dt < 0 && options.clockseq === undefined) { clockseq = clockseq + 1 & 0x3fff; }
        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) { nsecs = 0; }
        if (nsecs >= 10000) { throw new Error("uuid.v1(): Can't create more than 10M uuids/sec"); }
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
        msecs += 12219292800000;
        var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
        b[i++] = tl >>> 24 & 0xff;
        b[i++] = tl >>> 16 & 0xff;
        b[i++] = tl >>> 8 & 0xff;
        b[i++] = tl & 0xff;
        var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
        b[i++] = tmh >>> 8 & 0xff;
        b[i++] = tmh & 0xff;
        b[i++] = tmh >>> 24 & 0xf | 0x10;
        b[i++] = tmh >>> 16 & 0xff;
        b[i++] = clockseq >>> 8 | 0x80;
        b[i++] = clockseq & 0xff;
        for (var n = 0; n < 6; ++n) { b[i + n] = node[n]; }
        return buf || stringify(b);
      }
      var randomBytes;
      var rng = function rng() {
        if (!randomBytes) {
          var global = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : null;
          var crypto = global.crypto || global.msCrypto;
          if (crypto && crypto.getRandomValues) {
            randomBytes = function randomBytes(size) {
              var bytes = new Uint8Array(size);
              crypto.getRandomValues(bytes);
              return bytes;
            };
          }
        }
        if (!randomBytes) { throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');}
        return randomBytes(16);
      };
      function v4(options, buf, offset) {
        options = options || {};
        var rnds = options.random || (options.rng || rng)();
        rnds[6] = rnds[6] & 0x0f | 0x40;
        rnds[8] = rnds[8] & 0x3f | 0x80;
        if (buf) {
          offset = offset || 0;
          for (var i = 0; i < 16; ++i) { buf[offset + i] = rnds[i]; }
          return buf;
        }
        return stringify(rnds);
      }
      exports.NIL = '00000000-0000-0000-0000-000000000000';
      exports.v1 = v1;
      exports.v4 = v4;
      exports.validate = validate;
      exports.stringify = stringify;
      Object.defineProperty(exports, '__esModule', { value: true });
    })));
    </script>

    <style type="text/tailwindcss">
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #F8F9FA;
            overscroll-behavior: none;
            /* MODIFIÉ: Désactive la sélection de texte globalement */
            user-select: none;
        }
        #whiteboard-canvas {
            touch-action: none;
        }
        /* MODIFIÉ: Gestion fine du scroll par vue */
        #view-lobby { overflow-y: auto; }
        #view-whiteboard { overflow: hidden; }

        @layer components {
            .card { @apply bg-white rounded-xl shadow-lg transition-all; }
            .btn { @apply px-4 py-2 rounded-lg font-semibold text-white transition-all duration-150 ease-in-out select-none; }
            .btn-primary { @apply bg-blue-500 hover:bg-blue-600 active:scale-[0.98]; }
            .btn-secondary { @apply bg-gray-200 text-gray-700 hover:bg-gray-300 active:scale-[0.98]; }
            .input-field { @apply w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-400; }
        }
        .drawing-cursor { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='black' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='4'/></svg>") 12 12, auto; }
        .eraser-cursor { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'/></svg>") 12 12, auto; }
        .panning-cursor { cursor: grab; }
        .panning-cursor:active { cursor: grabbing; }
        .fade-in { animation: fadeIn 0.5s ease-in-out forwards; }
        .fade-out { animation: fadeOut 0.5s ease-in-out forwards; }
        .slide-up { animation: slideUp 0.5s ease-in-out forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; display: none; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    </style>
</head>
<body class="w-screen h-screen">

    <div id="app-container" class="w-full h-full">

        <div id="modal-username" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-50 fade-in">
            <div class="card w-full max-w-sm p-6 sm:p-8 text-center mx-4 sm:mx-0">
                <h1 class="text-2xl font-bold text-gray-800 mb-2">Welcome to Drawlima</h1>
                <p class="text-gray-500 mb-6">Choose a username to start collaborating.</p>
                <form id="form-username">
                    <input type="text" id="input-username" placeholder="Enter your name..." class="input-field mb-4" required>
                    <button type="submit" class="btn btn-primary w-full">Continue</button>
                </form>
            </div>
        </div>

        <div id="view-lobby" class="hidden w-full h-full p-4 md:p-8">
            <div class="max-w-4xl mx-auto">
                <div class="flex flex-wrap justify-between items-center gap-y-4 mb-6">
                    <h1 class="text-3xl font-bold text-gray-800">Whiteboards</h1>
                    <div class="flex items-center gap-2 sm:gap-4 w-full md:w-auto justify-end">
                        <span class="text-sm text-gray-600 mr-auto md:mr-0">Connected as: <strong id="lobby-username" class="font-semibold text-gray-800"></strong></span>
                        <button id="btn-logout-lobby" class="btn btn-secondary text-sm !px-3 !py-1.5">Logout</button>
                        <button id="btn-create-new" class="btn btn-primary">Create New</button>
                    </div>
                </div>
                <div id="whiteboard-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                </div>
            </div>
        </div>
        
        <div id="modal-create-whiteboard" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-50">
            <div class="card w-full max-w-sm p-8 mx-4 sm:mx-0">
                <h2 class="text-xl font-bold mb-4">Create a New Whiteboard</h2>
                <form id="form-create-whiteboard">
                    <label for="input-whiteboard-name" class="block text-sm font-medium text-gray-600 mb-1">Name</label>
                    <input type="text" id="input-whiteboard-name" placeholder="My Awesome Project" class="input-field mb-4" required>
                    <label for="select-whiteboard-size" class="block text-sm font-medium text-gray-600 mb-1">Canvas Size</label>
                    <select id="select-whiteboard-size" class="input-field mb-6">
                        <option value="1000x1000">Small (1000 x 1000)</option>
                        <option value="3000x3000" selected>Medium (3000 x 3000)</option>
                        <option value="5000x5000">Large (5000 x 5000)</option>
                    </select>
                    <div class="flex justify-end gap-3">
                        <button type="button" id="btn-cancel-create" class="btn btn-secondary">Cancel</button>
                        <button type="submit" class="btn btn-primary">Create</button>
                    </div>
                </form>
            </div>
        </div>


        <div id="view-whiteboard" class="hidden w-full h-full relative">
            <canvas id="whiteboard-canvas" class="absolute top-0 left-0"></canvas>
            <div id="cursors-container" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>

            <div id="toolbar" class="absolute bottom-4 left-4 right-4 md:left-1/2 md:-translate-x-1/2 md:w-auto md:right-auto flex items-center justify-center flex-wrap gap-2 p-2 card slide-up">
                <div class="flex items-center gap-1">
                    <button class="color-btn w-6 h-6 rounded-full border-2 border-blue-500" style="background-color: #EF4444;" data-color="#EF4444"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #F97316;" data-color="#F97316"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #84CC16;" data-color="#84CC16"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #3B82F6;" data-color="#3B82F6"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #8B5CF6;" data-color="#8B5CF6"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #000000;" data-color="#000000"></button>
                    <input type="color" id="color-picker-native" class="w-0 h-0 opacity-0 absolute">
                    <button id="btn-more-colors" class="w-6 h-6 rounded-full flex items-center justify-center bg-gray-200 text-gray-600">+</button>
                </div>
                <div class="h-6 w-px bg-gray-200"></div>
                <div class="flex items-center gap-2">
                    <span class="text-sm">Size:</span>
                    <input type="range" id="thickness-slider" min="2" max="50" value="5" class="w-24">
                </div>
                <div class="h-6 w-px bg-gray-200"></div>
                <button id="tool-brush" class="p-2 rounded-md bg-blue-100 text-blue-600">Brush</button>
                <button id="tool-eraser" class="p-2 rounded-md">Eraser</button>
                 <div class="h-6 w-px bg-gray-200"></div>
                <button id="btn-back-to-lobby" class="btn btn-secondary text-sm">Lobby</button>
            </div>
            
            <div id="user-list-overlay" class="absolute top-4 right-4 card p-2 sm:p-3 flex flex-col gap-2 max-w-[60%] sm:max-w-xs">
                <div>
                    <h3 class="font-semibold text-sm mb-2">Online</h3>
                    <div id="user-list-content" class="flex flex-col gap-1"></div>
                </div>
                <div class="border-t border-gray-200 pt-2 mt-1">
                    <div class="text-xs text-gray-500 truncate">
                        Connected as: 
                        <strong id="whiteboard-username" class="font-medium text-gray-700 inline-block max-w-full truncate align-bottom"></strong>
                    </div>
                    <button id="btn-logout-whiteboard" class="block w-full text-left text-sm text-red-500 hover:text-red-700 font-semibold mt-1">Logout</button>
                </div>
           </div>
        </div>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- CONFIGURATION ---
        const WS_URL = 'wss://miaou.vps.webdock.cloud/drawlima/';

        // --- STATE MANAGEMENT ---
        let ws;
        let userId = null;
        let username = null;
        let currentRoomId = null;
        let otherUsersInRoom = new Map();
        let userCursors = new Map();
        
        let committedStrokes = [];
        let activeStrokes = new Map();

        let localAction = {
            isDrawing: false,
            isPanning: false,
            isErasing: false,
            currentStrokeId: null,
            panStart: { x: 0, y: 0 },
            touchStartDist: 0,
            lastSentCursorTime: 0
        };
        
        let tool = 'brush';
        let drawingConfig = {
            color: '#EF4444',
            thickness: 5,
        };
        
        let viewport = {
            panX: 0, panY: 0, zoom: 1,
            worldWidth: 3000, worldHeight: 3000
        };

        // --- DOM ELEMENTS ---
        const usernameModal = document.getElementById('modal-username');
        const usernameForm = document.getElementById('form-username');
        const usernameInput = document.getElementById('input-username');
        const lobbyView = document.getElementById('view-lobby');
        const whiteboardListEl = document.getElementById('whiteboard-list');
        const createNewBtn = document.getElementById('btn-create-new');
        const createModal = document.getElementById('modal-create-whiteboard');
        const createForm = document.getElementById('form-create-whiteboard');
        const cancelCreateBtn = document.getElementById('btn-cancel-create');
        const whiteboardView = document.getElementById('view-whiteboard');
        const canvas = document.getElementById('whiteboard-canvas');
        const ctx = canvas.getContext('2d');
        const cursorsContainer = document.getElementById('cursors-container');
        const userListContent = document.getElementById('user-list-content');
        const colorBtns = document.querySelectorAll('.color-btn');
        const moreColorsBtn = document.getElementById('btn-more-colors');
        const nativeColorPicker = document.getElementById('color-picker-native');
        const thicknessSlider = document.getElementById('thickness-slider');
        const brushToolBtn = document.getElementById('tool-brush');
        const eraserToolBtn = document.getElementById('tool-eraser');
        const backToLobbyBtn = document.getElementById('btn-back-to-lobby');
        const lobbyUsernameEl = document.getElementById('lobby-username');
        const whiteboardUsernameEl = document.getElementById('whiteboard-username');
        const logoutLobbyBtn = document.getElementById('btn-logout-lobby');
        const logoutWhiteboardBtn = document.getElementById('btn-logout-whiteboard');

        // --- INITIALIZATION ---
        function init() {
            const savedUserId = localStorage.getItem('drawlima_userId');
            const savedUsername = localStorage.getItem('drawlima_username');

            if (savedUserId && savedUsername) {
                handleAuthentication(savedUsername, savedUserId);
            } else {
                usernameModal.classList.remove('hidden');
            }
            
            usernameForm.addEventListener('submit', handleUsernameSubmit);
            createNewBtn.addEventListener('click', () => createModal.classList.remove('hidden'));
            cancelCreateBtn.addEventListener('click', () => createModal.classList.add('hidden'));
            createForm.addEventListener('submit', handleCreateRoom);
            backToLobbyBtn.addEventListener('click', handleLeaveRoom);
            window.addEventListener('resize', resizeCanvas);
            logoutLobbyBtn.addEventListener('click', handleLogout);
            logoutWhiteboardBtn.addEventListener('click', handleLogout);

            setupToolbar();
            setupCanvasEvents();
        }

        // --- AUTH & WEBSOCKET FLOW ---
        function handleUsernameSubmit(e) {
            e.preventDefault();
            const name = usernameInput.value.trim();
            if (name) handleAuthentication(name);
        }

        function handleAuthentication(name, token = null) {
            username = name;
            userId = token;
            usernameModal.classList.add('fade-out');
            setTimeout(() => usernameModal.classList.add('hidden'), 500);
            connectWebSocket();
        }
        
        function handleLogout() {
            localStorage.removeItem('drawlima_userId');
            localStorage.removeItem('drawlima_username');
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.onclose = null; 
                ws.close();
            }
            window.location.reload();
        }

        function connectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) return;
            ws = new WebSocket(WS_URL);

            ws.onopen = () => sendMessage('auth', { username, token: userId });
            ws.onmessage = ({ data }) => handleWebSocketMessage(JSON.parse(data));
            ws.onclose = () => setTimeout(connectWebSocket, 3000);
            ws.onerror = (error) => console.error('WebSocket error:', error);
        }

        function sendMessage(type, payload) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type, payload }));
            }
        }
        
        function handleWebSocketMessage({ type, payload }) {
            switch (type) {
                case 'authenticated':
                    userId = payload.userId;
                    localStorage.setItem('drawlima_userId', userId);
                    localStorage.setItem('drawlima_username', username);
                    lobbyUsernameEl.textContent = username;
                    whiteboardUsernameEl.textContent = username;
                    updateWhiteboardList(payload.whiteboards);
                    showView('lobby');
                    break;
                case 'room_list_update':
                    updateWhiteboardList(payload.whiteboards);
                    break;
                case 'joined_room':
                    currentRoomId = payload.roomId;
                    viewport.worldWidth = payload.size.width;
                    viewport.worldHeight = payload.size.height;
                    committedStrokes = payload.strokes;
                    activeStrokes = new Map((payload.activeStrokes || []).map(s => [s.id, s]));
                    otherUsersInRoom.clear();
                    payload.users.forEach(u => {
                        if (u.id !== userId) otherUsersInRoom.set(u.id, u);
                    });
                    showView('whiteboard');
                    setupWhiteboard();
                    break;
                case 'user_joined':
                    if (payload.user.id !== userId) {
                        otherUsersInRoom.set(payload.user.id, payload.user);
                        updateUserList();
                    }
                    break;
                case 'user_left':
                    otherUsersInRoom.delete(payload.userId);
                    removeCursor(payload.userId);
                    updateUserList();
                    break;
                case 'start_stroke':
                    activeStrokes.set(payload.id, payload);
                    redrawCanvas();
                    break;
                case 'draw_chunk':
                    const strokeToUpdate = activeStrokes.get(payload.strokeId);
                    if (strokeToUpdate) {
                        strokeToUpdate.points.push(payload.point);
                        drawStrokeSegment(strokeToUpdate, strokeToUpdate.points.length - 2);
                    }
                    break;
                case 'end_stroke':
                    const finishedStroke = activeStrokes.get(payload.strokeId);
                    if (finishedStroke) {
                        committedStrokes.push(finishedStroke);
                        activeStrokes.delete(payload.strokeId);
                        redrawCanvas();
                    }
                    break;
                case 'delete_stroke':
                    committedStrokes = committedStrokes.filter(s => s.id !== payload.strokeId);
                    redrawCanvas();
                    break;
                case 'cursor_update':
                    updateCursor(payload);
                    break;
            }
        }
        
        // --- VIEW & ROOM MANAGEMENT ---
        function showView(view) {
            usernameModal.classList.add('hidden');
            lobbyView.classList.add('hidden');
            whiteboardView.classList.add('hidden');
            if (view === 'lobby') lobbyView.classList.remove('hidden');
            if (view === 'whiteboard') whiteboardView.classList.remove('hidden');
        }

        function updateWhiteboardList(whiteboards) {
            whiteboardListEl.innerHTML = !whiteboards || whiteboards.length === 0 
                ? `<p class="text-gray-500 col-span-full text-center">No whiteboards yet. Why not create one?</p>`
                : whiteboards.map(room => `
                    <div class="card p-4 flex flex-col justify-between hover:shadow-xl cursor-pointer" data-room-id="${room.id}">
                        <div><h3 class="font-bold text-lg truncate">${room.name}</h3><p class="text-sm text-gray-500">by ${room.creator}</p></div>
                        <div class="mt-4 text-sm text-gray-600 flex justify-between items-center">
                            <span>${room.userCount} user(s) online</span>
                            <span>${new Date(room.createdAt).toLocaleDateString()}</span>
                        </div>
                    </div>`).join('');
            
            whiteboardListEl.querySelectorAll('[data-room-id]').forEach(card => {
                card.addEventListener('click', () => sendMessage('join_room', { roomId: card.dataset.roomId }));
            });
        }

        function handleCreateRoom(e) {
            e.preventDefault();
            const name = document.getElementById('input-whiteboard-name').value;
            const [width, height] = document.getElementById('select-whiteboard-size').value.split('x').map(Number);
            if (name) {
                sendMessage('create_room', { name, size: {width, height} });
                createModal.classList.add('hidden');
                createForm.reset();
            }
        }
        function handleLeaveRoom() {
            showView('lobby');
            currentRoomId = null;
        }

        // --- CANVAS & DRAWING LOGIC ---
        function setupWhiteboard() {
            resizeCanvas();
            resetViewport();
            redrawCanvas();
            updateUserList();
            setCursor(tool);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            redrawCanvas();
        }
        
        function resetViewport() {
            viewport.panX = (canvas.width / 2) - (viewport.worldWidth / 2 * viewport.zoom);
            viewport.panY = (canvas.height / 2) - (viewport.worldHeight / 2 * viewport.zoom);
        }

        function setupCanvasEvents() {
            canvas.addEventListener('mousedown', startAction);
            canvas.addEventListener('mousemove', moveAction);
            canvas.addEventListener('mouseup', endAction);
            canvas.addEventListener('mouseout', endAction);
            canvas.addEventListener('wheel', handleZoom, { passive: false });
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
        }
        
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }
        
        function startAction(e) {
            if (e.button === 2) {
                localAction.isPanning = true;
                localAction.panStart = { x: e.clientX, y: e.clientY };
                setCursor('panning');
                return;
            }
            if (e.button !== 0 && !e.touches) return;
            
            const { x: canvasX, y: canvasY } = getCanvasCoordinates(e);
            let [worldX, worldY] = screenToWorld(canvasX, canvasY);
            worldX = Math.max(0, Math.min(viewport.worldWidth, worldX));
            worldY = Math.max(0, Math.min(viewport.worldHeight, worldY));

            if (tool === 'eraser') {
                localAction.isErasing = true;
                eraseAtPoint(worldX, worldY);
            } else {
                localAction.isDrawing = true;
                localAction.currentStrokeId = uuid.v4();
                const newStroke = { id: localAction.currentStrokeId, userId, tool: 'brush', color: drawingConfig.color, thickness: drawingConfig.thickness, points: [{x: worldX, y: worldY}] };
                activeStrokes.set(localAction.currentStrokeId, newStroke);
                sendMessage('start_stroke', newStroke);
                redrawCanvas();
            }
        }

        function moveAction(e) {
            if (localAction.isPanning) {
                const dx = e.clientX - localAction.panStart.x;
                const dy = e.clientY - localAction.panStart.y;
                viewport.panX += dx;
                viewport.panY += dy;
                localAction.panStart = { x: e.clientX, y: e.clientY };
                redrawCanvas();
                updateAllCursorPositions();
                return;
            }

            const { x: canvasX, y: canvasY } = getCanvasCoordinates(e);
            let [worldX, worldY] = screenToWorld(canvasX, canvasY);
            worldX = Math.max(0, Math.min(viewport.worldWidth, worldX));
            worldY = Math.max(0, Math.min(viewport.worldHeight, worldY));

            const now = Date.now();
            if (now - localAction.lastSentCursorTime > 50) {
                 sendMessage('cursor_move', { x: worldX, y: worldY, color: drawingConfig.color });
                 localAction.lastSentCursorTime = now;
            }

            if (!localAction.isDrawing && !localAction.isErasing) return;
            
            if (localAction.isDrawing) {
                const current = activeStrokes.get(localAction.currentStrokeId);
                if (current) {
                    const newPoint = {x: worldX, y: worldY};
                    current.points.push(newPoint);
                    sendMessage('draw_chunk', { strokeId: localAction.currentStrokeId, point: newPoint });
                    drawStrokeSegment(current, current.points.length - 2);
                }
            } else if (localAction.isErasing) {
                eraseAtPoint(worldX, worldY);
            }
        }
        
        function endAction(e) {
            if (localAction.isPanning) {
                localAction.isPanning = false;
                setCursor(tool);
            }
            if (localAction.isDrawing) {
                const finishedStroke = activeStrokes.get(localAction.currentStrokeId);
                if (finishedStroke) {
                    sendMessage('end_stroke', { strokeId: localAction.currentStrokeId });
                    committedStrokes.push(finishedStroke);
                    activeStrokes.delete(localAction.currentStrokeId);
                }
            }
            localAction.isDrawing = false;
            localAction.isErasing = false;
            localAction.currentStrokeId = null;
        }
        
        function eraseAtPoint(x, y) {
            const eraserRadius = 15;
            let needsRedraw = false;
            for (let i = committedStrokes.length - 1; i >= 0; i--) {
                const stroke = committedStrokes[i];
                if (stroke.userId !== userId) continue;
                for (const point of stroke.points) {
                    if (Math.hypot(point.x - x, point.y - y) < (eraserRadius + stroke.thickness / 2) / viewport.zoom) {
                        sendMessage('delete_stroke', { strokeId: stroke.id });
                        committedStrokes.splice(i, 1);
                        needsRedraw = true;
                        break; 
                    }
                }
                if (needsRedraw) break;
            }
            if (needsRedraw) redrawCanvas();
        }

        function redrawCanvas() {
            if (!currentRoomId) return;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();

            const [tlx, tly] = worldToScreen(0, 0);
            const [brx, bry] = worldToScreen(viewport.worldWidth, viewport.worldHeight);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(tlx, tly, brx - tlx, bry - tly);
            ctx.strokeStyle = '#E5E7EB';
            ctx.strokeRect(tlx, tly, brx - tlx, bry - tly);

            committedStrokes.forEach(drawFullStroke);
            activeStrokes.forEach(drawFullStroke);
        }

        function drawFullStroke(stroke) {
            if (!stroke || stroke.points.length < 1) return;
            ctx.beginPath();
            const startPoint = worldToScreen(stroke.points[0].x, stroke.points[0].y);
            ctx.moveTo(startPoint[0], startPoint[1]);
            ctx.lineWidth = stroke.thickness * viewport.zoom;
            ctx.strokeStyle = stroke.color;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            for (let i = 1; i < stroke.points.length; i++) {
                const point = worldToScreen(stroke.points[i].x, stroke.points[i].y);
                ctx.lineTo(point[0], point[1]);
            }
            ctx.stroke();
        }

        function drawStrokeSegment(stroke, fromIndex) {
            if (fromIndex < 0 || fromIndex >= stroke.points.length - 1) return;
            ctx.beginPath();
            const fromPoint = worldToScreen(stroke.points[fromIndex].x, stroke.points[fromIndex].y);
            const toPoint = worldToScreen(stroke.points[fromIndex + 1].x, stroke.points[fromIndex + 1].y);
            ctx.moveTo(fromPoint[0], fromPoint[1]);
            ctx.lineTo(toPoint[0], toPoint[1]);
            ctx.lineWidth = stroke.thickness * viewport.zoom;
            ctx.strokeStyle = stroke.color;
            ctx.lineCap = 'round';
            ctx.stroke();
        }

        function setupToolbar() {
            colorBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    colorBtns.forEach(b => b.style.borderColor = 'transparent');
                    btn.style.borderColor = '#3B82F6';
                    drawingConfig.color = btn.dataset.color;
                    setTool('brush');
                });
            });
            moreColorsBtn.addEventListener('click', () => nativeColorPicker.click());
            nativeColorPicker.addEventListener('input', (e) => {
                drawingConfig.color = e.target.value;
                setTool('brush');
            });
            thicknessSlider.addEventListener('input', (e) => drawingConfig.thickness = e.target.value);
            brushToolBtn.addEventListener('click', () => setTool('brush'));
            eraserToolBtn.addEventListener('click', () => setTool('eraser'));
        }
        function setTool(newTool) {
            tool = newTool;
            brushToolBtn.classList.toggle('bg-blue-100', tool === 'brush');
            brushToolBtn.classList.toggle('text-blue-600', tool === 'brush');
            eraserToolBtn.classList.toggle('bg-blue-100', tool === 'eraser');
            eraserToolBtn.classList.toggle('text-blue-600', tool === 'eraser');
            setCursor(tool);
        }
        function setCursor(cursorType) {
            canvas.className = '';
            if (cursorType === 'brush') canvas.classList.add('drawing-cursor');
            if (cursorType === 'eraser') canvas.classList.add('eraser-cursor');
            if (cursorType === 'panning') canvas.classList.add('panning-cursor');
        }
        function screenToWorld(x, y) { return [(x - viewport.panX) / viewport.zoom, (y - viewport.panY) / viewport.zoom]; }
        function worldToScreen(x, y) { return [x * viewport.zoom + viewport.panX, y * viewport.zoom + viewport.panY]; }
        
        function updateUserList() {
            userListContent.innerHTML = '';
            const selfEl = document.createElement('div');
            // MODIFIÉ: Ajout de 'truncate' pour couper les noms longs
            selfEl.className = 'text-sm font-semibold text-blue-600 truncate';
            selfEl.textContent = `${username} (You)`;
            userListContent.appendChild(selfEl);
            otherUsersInRoom.forEach(user => {
                 const userEl = document.createElement('div');
                 // MODIFIÉ: Ajout de 'truncate' pour couper les noms longs
                 userEl.className = 'text-sm text-gray-600 truncate';
                 userEl.textContent = user.username;
                 userListContent.appendChild(userEl);
            });
        }

        function updateCursor({ userId, username, x, y, color }) {
            if (!userCursors.has(userId)) {
                const cursorEl = document.createElement('div');
                cursorEl.className = 'absolute transition-transform duration-100 ease-linear';
                cursorEl.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="${color}" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="transform -rotate-45"><path d="M21.19,2.81,2.81,21.19a2,2,0,0,1-2.83-2.83L18.36,1.64a2,2,0,0,1,2.83,2.83Z"/></svg><span class="absolute top-5 left-2 px-2 py-0.5 text-xs text-white rounded-full" style="background-color: ${color};">${username}</span>`;
                cursorsContainer.appendChild(cursorEl);
                userCursors.set(userId, { element: cursorEl, color, username, worldX: x, worldY: y });
            }
            const cursor = userCursors.get(userId);
            cursor.worldX = x;
            cursor.worldY = y;
            const [screenX, screenY] = worldToScreen(x, y);
            cursor.element.style.transform = `translate(${screenX}px, ${screenY}px)`;
            if(cursor.color !== color) {
                cursor.color = color;
                cursor.element.querySelector('svg').style.fill = color;
                cursor.element.querySelector('span').style.backgroundColor = color;
            }
        }
        function removeCursor(userId) {
            if (userCursors.has(userId)) {
                userCursors.get(userId).element.remove();
                userCursors.delete(userId);
            }
        }
        function updateAllCursorPositions() {
            userCursors.forEach(cursor => {
                const [screenX, screenY] = worldToScreen(cursor.worldX, cursor.worldY);
                cursor.element.style.transform = `translate(${screenX}px, ${screenY}px)`;
            });
        }
        
        function handleZoom(e) {
            e.preventDefault();
            const zoomAmount = e.deltaY * -0.001;
            const newZoom = Math.max(0.1, Math.min(5, viewport.zoom * (1 + zoomAmount)));
            
            const { x: mouseX, y: mouseY } = getCanvasCoordinates(e);
            const [worldX, worldY] = screenToWorld(mouseX, mouseY);

            viewport.panX = mouseX - worldX * newZoom;
            viewport.panY = mouseY - worldY * newZoom;
            viewport.zoom = newZoom;
            redrawCanvas();
            updateAllCursorPositions();
        }
        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                startAction(e);
            } else if (e.touches.length === 2) {
                if (localAction.isDrawing) endAction(e);
                localAction.isPanning = true;
                
                const rect = canvas.getBoundingClientRect();
                const p1 = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
                const p2 = { x: e.touches[1].clientX - rect.left, y: e.touches[1].clientY - rect.top };

                localAction.panStart = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                localAction.touchStartDist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                setCursor('panning');
            }
        }
        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1 && !localAction.isPanning) {
                moveAction(e);
            } else if (e.touches.length === 2 && localAction.isPanning) {
                const rect = canvas.getBoundingClientRect();
                const p1 = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
                const p2 = { x: e.touches[1].clientX - rect.left, y: e.touches[1].clientY - rect.top };
                const panNow = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                const touchNowDist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                
                const dx = panNow.x - localAction.panStart.x;
                const dy = panNow.y - localAction.panStart.y;
                viewport.panX += dx;
                viewport.panY += dy;
                localAction.panStart = panNow;

                const zoomFactor = touchNowDist / localAction.touchStartDist;
                const newZoom = Math.max(0.1, Math.min(5, viewport.zoom * zoomFactor));
                const [worldX, worldY] = screenToWorld(panNow.x, panNow.y);
                viewport.panX = panNow.x - worldX * newZoom;
                viewport.panY = panNow.y - worldY * newZoom;
                viewport.zoom = newZoom;
                localAction.touchStartDist = touchNowDist;
                
                redrawCanvas();
                updateAllCursorPositions();
            }
        }
        function handleTouchEnd(e) {
            e.preventDefault();
            endAction(e); 
            if(e.touches.length < 2) {
                 localAction.isPanning = false;
                 setCursor(tool);
            }
        }

        // --- Start the Application ---
        init();
    });
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawlima - Collaborative Whiteboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <style type="text/tailwindcss">
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #F8F9FA; /* Light neutral canvas background */
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }
        /* Custom classes for Claude-inspired UI */
        @layer components {
            .card {
                @apply bg-white rounded-xl shadow-lg transition-all;
            }
            .btn {
                @apply px-4 py-2 rounded-lg font-semibold text-white transition-all duration-150 ease-in-out;
            }
            .btn-primary {
                @apply bg-blue-500 hover:bg-blue-600 active:scale-[0.98];
            }
            .btn-secondary {
                @apply bg-gray-200 text-gray-700 hover:bg-gray-300 active:scale-[0.98];
            }
            .input-field {
                @apply w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-400;
            }
        }
        /* Crayon/Marker cursor style */
        .drawing-cursor {
            cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='black' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='4'/></svg>") 12 12, auto;
        }
        .panning-cursor { cursor: grab; }
        .panning-cursor:active { cursor: grabbing; }

        /* Smooth transitions */
        .fade-in { animation: fadeIn 0.5s ease-in-out forwards; }
        .fade-out { animation: fadeOut 0.5s ease-in-out forwards; }
        .slide-up { animation: slideUp 0.5s ease-in-out forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; display: none; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    </style>
</head>
<body class="overflow-hidden">

    <div id="app-container" class="w-screen h-screen">

        <div id="modal-username" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-50 fade-in">
            <div class="card w-full max-w-sm p-8 text-center">
                <h1 class="text-2xl font-bold text-gray-800 mb-2">Welcome to Drawlima</h1>
                <p class="text-gray-500 mb-6">Choose a username to start collaborating.</p>
                <form id="form-username">
                    <input type="text" id="input-username" placeholder="Enter your name..." class="input-field mb-4" required>
                    <button type="submit" class="btn btn-primary w-full">Continue</button>
                </form>
            </div>
        </div>

        <div id="view-lobby" class="hidden w-full h-full p-4 md:p-8 overflow-y-auto">
            <div class="max-w-4xl mx-auto">
                <div class="flex justify-between items-center mb-6">
                    <h1 class="text-3xl font-bold text-gray-800">Whiteboards</h1>
                    <button id="btn-create-new" class="btn btn-primary">Create New</button>
                </div>
                <div id="whiteboard-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    </div>
            </div>
        </div>
        <div id="modal-create-whiteboard" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-50">
            <div class="card w-full max-w-sm p-8">
                <h2 class="text-xl font-bold mb-4">Create a New Whiteboard</h2>
                <form id="form-create-whiteboard">
                    <label for="input-whiteboard-name" class="block text-sm font-medium text-gray-600 mb-1">Name</label>
                    <input type="text" id="input-whiteboard-name" placeholder="My Awesome Project" class="input-field mb-4" required>

                    <label for="select-whiteboard-size" class="block text-sm font-medium text-gray-600 mb-1">Canvas Size</label>
                    <select id="select-whiteboard-size" class="input-field mb-6">
                        <option value="1000x1000">Small (1000 x 1000)</option>
                        <option value="3000x3000" selected>Medium (3000 x 3000)</option>
                        <option value="5000x5000">Large (5000 x 5000)</option>
                    </select>
                    <div class="flex justify-end gap-3">
                        <button type="button" id="btn-cancel-create" class="btn btn-secondary">Cancel</button>
                        <button type="submit" class="btn btn-primary">Create</button>
                    </div>
                </form>
            </div>
        </div>


        <div id="view-whiteboard" class="hidden w-full h-full relative">
            <canvas id="whiteboard-canvas" class="absolute top-0 left-0"></canvas>
            <div id="cursors-container" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>

            <div id="toolbar" class="absolute bottom-4 left-1/2 -translate-x-1/2 flex items-center gap-2 p-2 card slide-up">
                <div class="flex items-center gap-1">
                    <button class="color-btn w-6 h-6 rounded-full border-2 border-blue-500" style="background-color: #EF4444;" data-color="#EF4444"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #F97316;" data-color="#F97316"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #84CC16;" data-color="#84CC16"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #3B82F6;" data-color="#3B82F6"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #8B5CF6;" data-color="#8B5CF6"></button>
                    <button class="color-btn w-6 h-6 rounded-full" style="background-color: #000000;" data-color="#000000"></button>
                    <input type="color" id="color-picker-native" class="w-0 h-0 opacity-0 absolute">
                    <button id="btn-more-colors" class="w-6 h-6 rounded-full flex items-center justify-center bg-gray-200 text-gray-600">+</button>
                </div>
                <div class="h-6 w-px bg-gray-200"></div>
                <div class="flex items-center gap-2">
                    <span class="text-sm">Size:</span>
                    <input type="range" id="thickness-slider" min="2" max="50" value="5" class="w-24">
                </div>
                <div class="h-6 w-px bg-gray-200"></div>
                <button id="tool-brush" class="p-2 rounded-md bg-blue-100 text-blue-600">Brush</button>
                <button id="tool-eraser" class="p-2 rounded-md">Eraser</button>
                 <div class="h-6 w-px bg-gray-200"></div>
                <button id="btn-back-to-lobby" class="btn btn-secondary text-sm">Lobby</button>
            </div>
            
            <div id="user-list-overlay" class="absolute top-4 right-4 card p-3">
                 <h3 class="font-semibold text-sm mb-2">Online</h3>
                 <div id="user-list-content"></div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- CONFIGURATION ---
        // IMPORTANT: Change this to your VPS's domain and port.
        // Use wss:// for secure connections (required for https sites).
        const WS_URL = 'wss://miaou.vps.webdock.cloud:8080';

        // --- STATE MANAGEMENT ---
        let ws;
        let userId = null;
        let username = null;
        let currentRoomId = null;
        let localStrokes = []; // Holds all strokes for the current room
        let userCursors = new Map(); // { userId -> { element, color, username } }
        let otherUsersInRoom = new Map(); // { userId -> { username } }

        // Drawing state
        let isDrawing = false;
        let isPanning = false;
        let lastX = 0;
        let lastY = 0;
        let currentStroke = null;
        let tool = 'brush'; // 'brush' or 'eraser'
        let drawingConfig = {
            color: '#EF4444',
            thickness: 5,
            eraserColor: '#F8F9FA'
        };
        
        // Panning and Zooming state
        let viewport = {
            panX: 0,
            panY: 0,
            zoom: 1,
            worldWidth: 3000,
            worldHeight: 3000
        };
        let panStart = { x: 0, y: 0 };
        let touchStartDist = 0;

        // --- DOM ELEMENTS ---
        const usernameModal = document.getElementById('modal-username');
        const usernameForm = document.getElementById('form-username');
        const usernameInput = document.getElementById('input-username');
        
        const lobbyView = document.getElementById('view-lobby');
        const whiteboardListEl = document.getElementById('whiteboard-list');
        const createNewBtn = document.getElementById('btn-create-new');
        const createModal = document.getElementById('modal-create-whiteboard');
        const createForm = document.getElementById('form-create-whiteboard');
        const cancelCreateBtn = document.getElementById('btn-cancel-create');

        const whiteboardView = document.getElementById('view-whiteboard');
        const canvas = document.getElementById('whiteboard-canvas');
        const ctx = canvas.getContext('2d');
        const cursorsContainer = document.getElementById('cursors-container');
        const userListOverlay = document.getElementById('user-list-overlay');
        const userListContent = document.getElementById('user-list-content');

        const toolbar = document.getElementById('toolbar');
        const colorBtns = document.querySelectorAll('.color-btn');
        const moreColorsBtn = document.getElementById('btn-more-colors');
        const nativeColorPicker = document.getElementById('color-picker-native');
        const thicknessSlider = document.getElementById('thickness-slider');
        const brushToolBtn = document.getElementById('tool-brush');
        const eraserToolBtn = document.getElementById('tool-eraser');
        const backToLobbyBtn = document.getElementById('btn-back-to-lobby');

        // --- INITIALIZATION ---
        function init() {
            // Setup initial event listeners
            usernameForm.addEventListener('submit', handleUsernameSubmit);
            createNewBtn.addEventListener('click', () => createModal.classList.remove('hidden'));
            cancelCreateBtn.addEventListener('click', () => createModal.classList.add('hidden'));
            createForm.addEventListener('submit', handleCreateRoom);
            backToLobbyBtn.addEventListener('click', handleLeaveRoom);

            setupToolbar();
            setupCanvasEvents();
        }

        // --- VIEW MANAGEMENT ---
        function showView(view) {
            usernameModal.classList.add('hidden');
            lobbyView.classList.add('hidden');
            whiteboardView.classList.add('hidden');
            if (view === 'lobby') lobbyView.classList.remove('hidden');
            if (view === 'whiteboard') whiteboardView.classList.remove('hidden');
        }

        // --- USER & WEBSOCKET FLOW ---

        function handleUsernameSubmit(e) {
            e.preventDefault();
            username = usernameInput.value.trim();
            if (username) {
                usernameModal.classList.add('fade-out');
                setTimeout(() => usernameModal.classList.add('hidden'), 500);
                connectWebSocket();
            }
        }

        function connectWebSocket() {
            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                console.log('WebSocket connected.');
                // Send username for authentication
                sendMessage('auth', { username });
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleWebSocketMessage(message);
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected. Attempting to reconnect...');
                // You might want to show a "disconnected" message to the user here.
                setTimeout(connectWebSocket, 3000); // Reconnect after 3 seconds
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                ws.close();
            };
        }

        function sendMessage(type, payload) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type, payload }));
            }
        }
        
        function handleWebSocketMessage({ type, payload }) {
            // console.log('Received message:', type, payload);
            switch (type) {
                case 'authenticated':
                    userId = payload.userId;
                    updateWhiteboardList(payload.whiteboards);
                    showView('lobby');
                    break;
                case 'room_list_update':
                    updateWhiteboardList(payload.whiteboards);
                    break;
                case 'joined_room':
                    currentRoomId = payload.roomId;
                    viewport.worldWidth = payload.size.width;
                    viewport.worldHeight = payload.size.height;
                    localStrokes = payload.strokes;
                    otherUsersInRoom.clear();
                    payload.users.forEach(u => {
                        if (u.id !== userId) otherUsersInRoom.set(u.id, u);
                    });
                    showView('whiteboard');
                    setupWhiteboard();
                    break;
                case 'user_joined':
                    if (payload.user.id !== userId) {
                        otherUsersInRoom.set(payload.user.id, payload.user);
                        updateUserList();
                    }
                    break;
                case 'user_left':
                    otherUsersInRoom.delete(payload.userId);
                    removeCursor(payload.userId);
                    updateUserList();
                    break;
                case 'new_stroke':
                    localStrokes.push(payload);
                    drawStroke(payload);
                    break;
                case 'stroke_deleted':
                    localStrokes = localStrokes.filter(s => s.id !== payload.strokeId);
                    redrawCanvas();
                    break;
                case 'cursor_update':
                    updateCursor(payload);
                    break;
            }
        }
        
        // --- LOBBY LOGIC ---
        
        function updateWhiteboardList(whiteboards) {
            whiteboardListEl.innerHTML = '';
            if (whiteboards.length === 0) {
                 whiteboardListEl.innerHTML = `<p class="text-gray-500 col-span-full text-center">No whiteboards yet. Why not create one?</p>`;
            } else {
                whiteboards.forEach(room => {
                    const card = document.createElement('div');
                    card.className = 'card p-4 flex flex-col justify-between hover:shadow-xl cursor-pointer';
                    card.dataset.roomId = room.id;
                    card.innerHTML = `
                        <div>
                            <h3 class="font-bold text-lg truncate">${room.name}</h3>
                            <p class="text-sm text-gray-500">by ${room.creator}</p>
                        </div>
                        <div class="mt-4 text-sm text-gray-600 flex justify-between items-center">
                            <span>${room.userCount} user(s) online</span>
                            <span>${new Date(room.createdAt).toLocaleDateString()}</span>
                        </div>
                    `;
                    card.addEventListener('click', () => {
                        sendMessage('join_room', { roomId: room.id });
                    });
                    whiteboardListEl.appendChild(card);
                });
            }
        }

        function handleCreateRoom(e) {
            e.preventDefault();
            const name = document.getElementById('input-whiteboard-name').value;
            const sizeValue = document.getElementById('select-whiteboard-size').value;
            const [width, height] = sizeValue.split('x').map(Number);
            
            if (name) {
                sendMessage('create_room', { name, size: {width, height} });
                createModal.classList.add('hidden');
                createForm.reset();
            }
        }
        
        function handleLeaveRoom() {
            showView('lobby');
            currentRoomId = null;
            localStrokes = [];
            // Inform server we left (implicitly handled by joining another room or disconnecting)
            // but for a clean UI transition, we do this client-side first.
        }

        // --- WHITEBOARD & CANVAS LOGIC ---
        
        function setupWhiteboard() {
            resizeCanvas();
            resetViewport();
            redrawCanvas();
            updateUserList();
            document.body.classList.add('drawing-cursor');
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            redrawCanvas();
        }
        
        function resetViewport() {
            viewport.panX = (canvas.width / 2) - (viewport.worldWidth / 2 * viewport.zoom);
            viewport.panY = (canvas.height / 2) - (viewport.worldHeight / 2 * viewport.zoom);
        }

        window.addEventListener('resize', resizeCanvas);

        function setupCanvasEvents() {
            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('wheel', handleZoom, { passive: false });

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
        }
        
        // --- Drawing ---
        function startDrawing(e) {
            if (e.button === 2) { // Right click for panning
                isPanning = true;
                panStart.x = e.clientX;
                panStart.y = e.clientY;
                document.body.classList.remove('drawing-cursor');
                document.body.classList.add('panning-cursor');
                return;
            }
            if (e.button !== 0) return; // Only left click draws
            
            isDrawing = true;
            const [x, y] = getCanvasCoords(e);
            const [worldX, worldY] = screenToWorld(x, y);

            currentStroke = {
                tool: tool,
                color: tool === 'eraser' ? drawingConfig.eraserColor : drawingConfig.color,
                thickness: drawingConfig.thickness,
                points: [{ x: worldX, y: worldY }]
            };
            
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function draw(e) {
            if (isPanning) {
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                viewport.panX += dx;
                viewport.panY += dy;
                panStart.x = e.clientX;
                panStart.y = e.clientY;
                redrawCanvas();
                return;
            }

            if (!isDrawing) {
                // Send cursor position even when not drawing
                const [x,y] = getCanvasCoords(e);
                const [worldX, worldY] = screenToWorld(x,y);
                sendMessage('cursor_move', { x: worldX, y: worldY, color: drawingConfig.color });
                return;
            }
            
            const [x, y] = getCanvasCoords(e);
            const [worldX, worldY] = screenToWorld(x, y);
            
            currentStroke.points.push({ x: worldX, y: worldY });
            
            ctx.lineWidth = drawingConfig.thickness * viewport.zoom;
            ctx.lineCap = 'round';
            ctx.strokeStyle = tool === 'eraser' ? drawingConfig.eraserColor : drawingConfig.color;
            
            // For that "crayon" texture
            ctx.globalAlpha = 0.8;
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        function stopDrawing(e) {
            if (isPanning) {
                isPanning = false;
                document.body.classList.remove('panning-cursor');
                document.body.classList.add('drawing-cursor');
            }

            if (isDrawing) {
                isDrawing = false;
                ctx.closePath();
                if (currentStroke && currentStroke.points.length > 1) {
                    localStrokes.push(currentStroke);
                    sendMessage('draw_stroke', currentStroke);
                }
                currentStroke = null;
            }
        }
        
        function drawStroke(stroke) {
            if (!stroke || stroke.points.length < 2) return;

            ctx.beginPath();
            const startPoint = worldToScreen(stroke.points[0].x, stroke.points[0].y);
            ctx.moveTo(startPoint[0], startPoint[1]);
            
            ctx.lineWidth = stroke.thickness * viewport.zoom;
            ctx.strokeStyle = stroke.color;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            for (let i = 1; i < stroke.points.length; i++) {
                const point = worldToScreen(stroke.points[i].x, stroke.points[i].y);
                ctx.lineTo(point[0], point[1]);
            }
            ctx.stroke();
            ctx.closePath();
        }

        function redrawCanvas() {
            if (!currentRoomId) return;
            // Clear canvas
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();

            // Draw background / world boundary
            const [tlx, tly] = worldToScreen(0, 0);
            const [brx, bry] = worldToScreen(viewport.worldWidth, viewport.worldHeight);
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(tlx, tly, brx - tlx, bry - tly);
            ctx.strokeStyle = '#E5E7EB';
            ctx.strokeRect(tlx, tly, brx - tlx, bry - tly);

            // Draw all strokes
            localStrokes.forEach(drawStroke);
        }

        // --- Panning & Zooming ---
        function handleZoom(e) {
            e.preventDefault();
            const zoomAmount = e.deltaY * -0.001;
            const newZoom = Math.max(0.1, Math.min(5, viewport.zoom * (1 + zoomAmount)));
            
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            const worldX = (mouseX - viewport.panX) / viewport.zoom;
            const worldY = (mouseY - viewport.panY) / viewport.zoom;
            
            viewport.panX = mouseX - worldX * newZoom;
            viewport.panY = mouseY - worldY * newZoom;
            viewport.zoom = newZoom;
            
            redrawCanvas();
        }
        
        function getCanvasCoords(e) {
            return [e.clientX, e.clientY];
        }

        function screenToWorld(x, y) {
            return [(x - viewport.panX) / viewport.zoom, (y - viewport.panY) / viewport.zoom];
        }

        function worldToScreen(x, y) {
            return [x * viewport.zoom + viewport.panX, y * viewport.zoom + viewport.panY];
        }

        // --- Touch controls ---
        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) { // Single finger for drawing
                startDrawing({ button: 0, clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
            } else if (e.touches.length === 2) { // Two fingers for panning/zooming
                isDrawing = false;
                isPanning = true;
                panStart.x = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                panStart.y = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                touchStartDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1 && isDrawing) {
                draw({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
            } else if (e.touches.length === 2 && isPanning) {
                // Panning
                const panNow = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                const dx = panNow.x - panStart.x;
                const dy = panNow.y - panStart.y;
                viewport.panX += dx;
                viewport.panY += dy;
                panStart.x = panNow.x;
                panStart.y = panNow.y;

                // Zooming
                const touchNowDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                const zoomFactor = touchNowDist / touchStartDist;
                
                const newZoom = Math.max(0.1, Math.min(5, viewport.zoom * zoomFactor));
                const worldX = (panNow.x - viewport.panX) / viewport.zoom;
                const worldY = (panNow.y - viewport.panY) / viewport.zoom;
                
                viewport.panX = panNow.x - worldX * newZoom;
                viewport.panY = panNow.y - worldY * newZoom;
                viewport.zoom = newZoom;

                touchStartDist = touchNowDist;
                
                redrawCanvas();
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            stopDrawing();
            isPanning = false;
        }

        // --- Toolbar ---
        function setupToolbar() {
            colorBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    colorBtns.forEach(b => b.style.borderColor = 'transparent');
                    btn.style.borderColor = '#3B82F6'; // a highlight color
                    drawingConfig.color = btn.dataset.color;
                    setTool('brush');
                });
            });
            
            moreColorsBtn.addEventListener('click', () => nativeColorPicker.click());
            nativeColorPicker.addEventListener('input', (e) => {
                drawingConfig.color = e.target.value;
                setTool('brush');
            });

            thicknessSlider.addEventListener('input', (e) => {
                drawingConfig.thickness = e.target.value;
            });
            
            brushToolBtn.addEventListener('click', () => setTool('brush'));
            eraserToolBtn.addEventListener('click', () => setTool('eraser'));
        }

        function setTool(newTool) {
            tool = newTool;
            brushToolBtn.classList.toggle('bg-blue-100', tool === 'brush');
            brushToolBtn.classList.toggle('text-blue-600', tool === 'brush');
            eraserToolBtn.classList.toggle('bg-blue-100', tool === 'eraser');
            eraserToolBtn.classList.toggle('text-blue-600', tool === 'eraser');
        }

        // --- Cursors & User List ---
        function updateCursor({ userId, username, x, y, color }) {
            if (!userCursors.has(userId)) {
                const cursorEl = document.createElement('div');
                cursorEl.className = 'absolute transition-transform duration-100 ease-linear';
                cursorEl.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="${color}" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="transform -rotate-45"><path d="M21.19,2.81,2.81,21.19a2,2,0,0,1-2.83-2.83L18.36,1.64a2,2,0,0,1,2.83,2.83Z"/></svg>
                    <span class="absolute top-5 left-2 px-2 py-0.5 text-xs text-white rounded-full" style="background-color: ${color};">${username}</span>
                `;
                cursorsContainer.appendChild(cursorEl);
                userCursors.set(userId, { element: cursorEl, color, username });
            }

            const cursor = userCursors.get(userId);
            const [screenX, screenY] = worldToScreen(x, y);
            cursor.element.style.transform = `translate(${screenX}px, ${screenY}px)`;
            
            // Update color if it has changed
            if(cursor.color !== color) {
                cursor.color = color;
                cursor.element.querySelector('svg').style.fill = color;
                cursor.element.querySelector('span').style.backgroundColor = color;
            }
        }
        
        function removeCursor(userId) {
            if (userCursors.has(userId)) {
                userCursors.get(userId).element.remove();
                userCursors.delete(userId);
            }
        }
        
        function updateUserList() {
            userListContent.innerHTML = '';
            // Add self
            const selfEl = document.createElement('div');
            selfEl.className = 'text-sm font-semibold';
            selfEl.textContent = `${username} (You)`;
            userListContent.appendChild(selfEl);

            // Add others
            otherUsersInRoom.forEach(user => {
                 const userEl = document.createElement('div');
                 userEl.className = 'text-sm text-gray-600';
                 userEl.textContent = user.username;
                 userListContent.appendChild(userEl);
            });
        }

        // --- Start the app ---
        init();
    });
    </script>
</body>
</html>